const { Markup } = require('telegraf');
const UserService = require('../../services/UserService');
const BlockchainService = require('../../services/BlockchainService');
const NotificationService = require('../../services/NotificationService');
const { formatNumber, formatDate } = require('../../utils/formatting');
const { getDatabase } = require('../../config/database');

class AdminHandler {
    constructor() {
        this.userService = new UserService();
        this.blockchainService = new BlockchainService();
        this.notificationService = new NotificationService();
        this.adminUserIds = process.env.ADMIN_USER_ID ? 
            process.env.ADMIN_USER_ID.split(',').map(id => id.trim()) : [];
    }

    async handle(ctx) {
        try {
            // Check admin permissions
            if (!this.isAdmin(ctx.from.id)) {
                await ctx.reply('‚ùå Access denied. Admin privileges required.');
                return;
            }

            const adminMessage = await this.buildAdminMessage();
            const keyboard = this.getAdminKeyboard();

            if (ctx.callbackQuery) {
                await ctx.editMessageText(adminMessage, {
                    parse_mode: 'Markdown',
                    ...keyboard
                });
                await ctx.answerCbQuery();
            } else {
                await ctx.reply(adminMessage, {
                    parse_mode: 'Markdown',
                    ...keyboard
                });
            }

        } catch (error) {
            console.error('‚ùå Admin handler error:', error);
            await ctx.reply('‚ùå Admin panel error. Please try again.');
        }
    }

    async buildAdminMessage() {
        try {
            const stats = await this.userService.getPlatformStats();
            const systemStats = await this.blockchainService.getSystemStats();
            
            return `üîß **Admin Control Panel**

**üìä Platform Overview:**
‚Ä¢ **Total Users:** ${stats?.users?.total_users || 0}
‚Ä¢ **Active Members:** ${stats?.users?.registered_users || 0}
‚Ä¢ **New Today:** ${stats?.users?.new_users_24h || 0}
‚Ä¢ **Total Revenue:** ${systemStats ? formatNumber(parseFloat(systemStats.totalRevenue)) : '0'} USDT

**‚ö° Quick Stats:**
‚Ä¢ **Pending Transactions:** ${stats?.transactions?.pending_transactions || 0}
‚Ä¢ **Success Rate:** ${this.calculateSuccessRate(stats?.transactions)}%
‚Ä¢ **Commission Paid:** ${systemStats ? formatNumber(parseFloat(systemStats.totalCommission)) : '0'} USDT

**üîß Admin Tools Available:**
Use the buttons below to manage the platform.

‚ö†Ô∏è **Admin Mode Active** - Handle with care!`;

        } catch (error) {
            console.error('‚ùå Error building admin message:', error);
            return `üîß **Admin Control Panel**\n\n‚ùå Error loading statistics.\n\nBasic admin functions are still available.`;
        }
    }

    getAdminKeyboard() {
        return Markup.inlineKeyboard([
            [
                Markup.button.callback('üë• Users', 'admin_users'),
                Markup.button.callback('üìä Statistics', 'admin_stats')
            ],
            [
                Markup.button.callback('üí∞ Transactions', 'admin_transactions'),
                Markup.button.callback('‚õìÔ∏è Blockchain', 'admin_blockchain')
            ],
            [
                Markup.button.callback('üì¢ Broadcast', 'admin_broadcast'),
                Markup.button.callback('üîß Settings', 'admin_settings')
            ],
            [
                Markup.button.callback('üìà Analytics', 'admin_analytics'),
                Markup.button.callback('üõ†Ô∏è Maintenance', 'admin_maintenance')
            ],
            [
                Markup.button.callback('üè† Main Menu', 'action_back_main')
            ]
        ]);
    }

    async handleAction(ctx, action) {
        try {
            if (!this.isAdmin(ctx.from.id)) {
                await ctx.answerCbQuery('‚ùå Access denied');
                return;
            }

            switch (action) {
                case 'users':
                    await this.showUsers(ctx);
                    break;
                case 'stats':
                    await this.handleStats(ctx);
                    break;
                case 'transactions':
                    await this.showTransactions(ctx);
                    break;
                case 'blockchain':
                    await this.showBlockchainInfo(ctx);
                    break;
                case 'broadcast':
                    await this.showBroadcast(ctx);
                    break;
                case 'settings':
                    await this.showSettings(ctx);
                    break;
                case 'analytics':
                    await this.showAnalytics(ctx);
                    break;
                case 'maintenance':
                    await this.showMaintenance(ctx);
                    break;
                default:
                    await ctx.answerCbQuery('‚ùå Unknown action');
            }

        } catch (error) {
            console.error(`‚ùå Admin action error (${action}):`, error);
            await ctx.answerCbQuery('‚ùå Action failed');
        }
    }

    async showUsers(ctx, page = 1) {
        try {
            const limit = 10;
            const offset = (page - 1) * limit;
            
            const result = await this.userService.getAllUsers(limit, offset);
            const users = result.users;
            
            let message = `üë• **User Management** (Page ${page})\n\n`;
            
            if (users.length === 0) {
                message += 'üì≠ No users found.';
            } else {
                users.forEach((user, index) => {
                    const status = user.is_registered ? 'üíé' : '‚≠ê';
                    const joined = formatDate(user.created_at, true);
                    message += `${status} **${user.first_name}**\n`;
                    message += `   @${user.username || 'no_username'} ‚Ä¢ ${joined}\n`;
                    message += `   Plan: ${user.plan_id || 'None'} ‚Ä¢ Referrals: ${user.total_referrals}\n\n`;
                });
                
                message += `**Total:** ${result.total} users`;
            }

            const keyboard = this.getUsersKeyboard(page, result.hasMore);

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();

        } catch (error) {
            console.error('‚ùå Show users error:', error);
            await ctx.answerCbQuery('‚ùå Failed to load users');
        }
    }

    getUsersKeyboard(page, hasMore) {
        const keyboard = [];
        
        // Pagination
        const navRow = [];
        if (page > 1) {
            navRow.push(Markup.button.callback('‚¨ÖÔ∏è Previous', `page_users_${page - 1}`));
        }
        if (hasMore) {
            navRow.push(Markup.button.callback('‚û°Ô∏è Next', `page_users_${page + 1}`));
        }
        if (navRow.length > 0) {
            keyboard.push(navRow);
        }

        keyboard.push([
            Markup.button.callback('üîç Search User', 'admin_search_user'),
            Markup.button.callback('üìä User Stats', 'admin_user_stats')
        ]);

        keyboard.push([
            Markup.button.callback('üîô Back', 'admin_main')
        ]);

        return Markup.inlineKeyboard(keyboard);
    }

    async handleStats(ctx) {
        try {
            const platformStats = await this.userService.getPlatformStats();
            const blockchainStats = await this.blockchainService.getSystemStats();
            
            const message = await this.buildStatsMessage(platformStats, blockchainStats);
            const keyboard = this.getStatsKeyboard();

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();

        } catch (error) {
            console.error('‚ùå Stats error:', error);
            await ctx.answerCbQuery('‚ùå Failed to load statistics');
        }
    }

    async buildStatsMessage(platformStats, blockchainStats) {
        let message = `üìä **Platform Statistics**\n\n`;

        if (platformStats) {
            message += `**üë• User Analytics:**
‚Ä¢ Total Users: ${platformStats.users.total_users}
‚Ä¢ Active Members: ${platformStats.users.registered_users}
‚Ä¢ Users with Wallets: ${platformStats.users.users_with_wallet}
‚Ä¢ New (24h): ${platformStats.users.new_users_24h}
‚Ä¢ New (7d): ${platformStats.users.new_users_7d}

**üìù Transaction Metrics:**
‚Ä¢ Total Transactions: ${platformStats.transactions.total_transactions}
‚Ä¢ Confirmed: ${platformStats.transactions.confirmed_transactions}
‚Ä¢ Pending: ${platformStats.transactions.pending_transactions}
‚Ä¢ Success Rate: ${this.calculateSuccessRate(platformStats.transactions)}%

**üë• Referral Performance:**
‚Ä¢ Total Referrals: ${platformStats.referrals.total_referrals}
‚Ä¢ Paid Referrals: ${platformStats.referrals.paid_referrals}
‚Ä¢ Commission Paid: ${formatNumber(parseFloat(platformStats.referrals.total_commission_paid))} USDT`;

            if (platformStats.plans && platformStats.plans.length > 0) {
                message += `\n\n**üèÜ Popular Plans:**`;
                platformStats.plans.slice(0, 5).forEach(plan => {
                    message += `\n‚Ä¢ Plan ${plan.plan_id}: ${plan.user_count} members`;
                });
            }
        }

        if (blockchainStats) {
            message += `\n\n**‚õìÔ∏è Blockchain Data:**
‚Ä¢ Total Members: ${blockchainStats.totalMembers}
‚Ä¢ Total Revenue: ${formatNumber(parseFloat(blockchainStats.totalRevenue))} USDT
‚Ä¢ Total Commission: ${formatNumber(parseFloat(blockchainStats.totalCommission))} USDT
‚Ä¢ Owner Funds: ${formatNumber(parseFloat(blockchainStats.ownerFunds))} USDT
‚Ä¢ Fee Funds: ${formatNumber(parseFloat(blockchainStats.feeFunds))} USDT`;
        }

        message += `\n\nüìÖ **Generated:** ${formatDate(new Date())}`;

        return message;
    }

    getStatsKeyboard() {
        return Markup.inlineKeyboard([
            [
                Markup.button.callback('üìà Detailed Analytics', 'admin_analytics'),
                Markup.button.callback('üí∞ Financial Report', 'admin_financial')
            ],
            [
                Markup.button.callback('üîÑ Refresh', 'admin_stats'),
                Markup.button.callback('üìä Export Data', 'admin_export')
            ],
            [
                Markup.button.callback('üîô Back', 'admin_main')
            ]
        ]);
    }

    async showTransactions(ctx, page = 1) {
        try {
            const limit = 10;
            const offset = (page - 1) * limit;
            
            const db = getDatabase();
            const transactions = await db.all(`
                SELECT t.*, u.telegram_id, u.first_name, u.username
                FROM transactions t
                JOIN users u ON t.user_id = u.id
                ORDER BY t.created_at DESC
                LIMIT ? OFFSET ?
            `, [limit, offset]);

            const totalCount = await db.get('SELECT COUNT(*) as count FROM transactions');
            const hasMore = (offset + transactions.length) < totalCount.count;

            let message = `üí∞ **Transaction History** (Page ${page})\n\n`;

            if (transactions.length === 0) {
                message += 'üì≠ No transactions found.';
            } else {
                transactions.forEach(tx => {
                    const status = this.getStatusEmoji(tx.status);
                    const amount = formatNumber(parseFloat(tx.amount));
                    const date = formatDate(tx.created_at, true);
                    
                    message += `${status} **${tx.type.toUpperCase()}**\n`;
                    message += `   ${tx.first_name} ‚Ä¢ ${amount} USDT\n`;
                    message += `   ${date} ‚Ä¢ Hash: \`${tx.tx_hash?.slice(0, 10)}...\`\n\n`;
                });

                message += `**Total:** ${totalCount.count} transactions`;
            }

            const keyboard = this.getTransactionsKeyboard(page, hasMore);

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();

        } catch (error) {
            console.error('‚ùå Show transactions error:', error);
            await ctx.answerCbQuery('‚ùå Failed to load transactions');
        }
    }

    getTransactionsKeyboard(page, hasMore) {
        const keyboard = [];
        
        // Pagination
        const navRow = [];
        if (page > 1) {
            navRow.push(Markup.button.callback('‚¨ÖÔ∏è Previous', `page_transactions_${page - 1}`));
        }
        if (hasMore) {
            navRow.push(Markup.button.callback('‚û°Ô∏è Next', `page_transactions_${page + 1}`));
        }
        if (navRow.length > 0) {
            keyboard.push(navRow);
        }

        keyboard.push([
            Markup.button.callback('üîç Filter', 'admin_filter_tx'),
            Markup.button.callback('üìä TX Stats', 'admin_tx_stats')
        ]);

        keyboard.push([
            Markup.button.callback('üîô Back', 'admin_main')
        ]);

        return Markup.inlineKeyboard(keyboard);
    }

    async showBlockchainInfo(ctx) {
        try {
            const blockchainStatus = this.blockchainService.getStatus();
            const systemStats = await this.blockchainService.getSystemStats();
            
            let message = `‚õìÔ∏è **Blockchain Information**\n\n`;

            message += `**üîó Connection Status:**
‚Ä¢ Connected: ${blockchainStatus.connected ? '‚úÖ' : '‚ùå'}
‚Ä¢ Network: BSC Testnet
‚Ä¢ Last Block: ${blockchainStatus.lastBlockNumber}

**üìã Contract Addresses:**
‚Ä¢ NFT Contract: \`${blockchainStatus.contractAddresses.nft}\`
‚Ä¢ USDT Contract: \`${blockchainStatus.contractAddresses.usdt}\``;

            if (systemStats) {
                message += `\n\n**üí∞ Contract Balances:**
‚Ä¢ Owner Funds: ${formatNumber(parseFloat(systemStats.ownerFunds))} USDT
‚Ä¢ Fee System: ${formatNumber(parseFloat(systemStats.feeFunds))} USDT
‚Ä¢ Fund Balance: ${formatNumber(parseFloat(systemStats.fundFunds))} USDT

**üìä Contract Stats:**
‚Ä¢ Total Members: ${systemStats.totalMembers}
‚Ä¢ Total Revenue: ${formatNumber(parseFloat(systemStats.totalRevenue))} USDT
‚Ä¢ Commission Paid: ${formatNumber(parseFloat(systemStats.totalCommission))} USDT`;
            }

            const keyboard = this.getBlockchainKeyboard();

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();

        } catch (error) {
            console.error('‚ùå Show blockchain info error:', error);
            await ctx.answerCbQuery('‚ùå Failed to load blockchain information');
        }
    }

    getBlockchainKeyboard() {
        return Markup.inlineKeyboard([
            [
                Markup.button.callback('üí∞ Withdraw Funds', 'admin_withdraw'),
                Markup.button.callback('üîÑ Sync Events', 'admin_sync_events')
            ],
            [
                Markup.button.callback('‚öôÔ∏è Contract Settings', 'admin_contract_settings'),
                Markup.button.callback('üìä Gas Tracker', 'admin_gas_tracker')
            ],
            [
                Markup.button.callback('üîô Back', 'admin_main')
            ]
        ]);
    }

    async showBroadcast(ctx) {
        const message = `üì¢ **Broadcast Message**

Send a message to all active users.

**‚ö†Ô∏è Important:**
‚Ä¢ Message will be sent to ALL active users
‚Ä¢ Use this feature responsibly
‚Ä¢ Include clear and valuable information
‚Ä¢ Avoid spam or frequent messages

**üìä Current Recipients:**
‚Ä¢ Active users who will receive the message
‚Ä¢ Rate limiting: 1 message per second
‚Ä¢ Delivery report will be provided

Type your broadcast message:`;

        const keyboard = Markup.inlineKeyboard([
            [Markup.button.callback('‚ùå Cancel', 'admin_main')]
        ]);

        await ctx.editMessageText(message, {
            parse_mode: 'Markdown',
            ...keyboard
        });
        await ctx.answerCbQuery();

        // Set conversation state
        ctx.session.step = 'waiting_broadcast_message';
    }

    async handleBroadcast(ctx) {
        try {
            if (!this.isAdmin(ctx.from.id)) {
                await ctx.reply('‚ùå Access denied');
                return;
            }

            const stats = await this.userService.getPlatformStats();
            const totalUsers = stats?.users?.total_users || 0;

            const message = `üì¢ **Confirm Broadcast**

**Message Preview:**
"${ctx.message.text.slice(0, 200)}${ctx.message.text.length > 200 ? '...' : ''}"

**üìä Delivery Details:**
‚Ä¢ Recipients: ${totalUsers} active users
‚Ä¢ Estimated time: ${Math.ceil(totalUsers / 60)} minutes
‚Ä¢ Rate limit: 1 msg/second

‚ö†Ô∏è **This action cannot be undone!**

Proceed with broadcast?`;

            const keyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback('‚úÖ Send Broadcast', 'admin_confirm_broadcast'),
                    Markup.button.callback('‚ùå Cancel', 'admin_main')
                ]
            ]);

            await ctx.reply(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });

            // Store message for broadcast
            ctx.session.broadcastMessage = ctx.message.text;

        } catch (error) {
            console.error('‚ùå Handle broadcast error:', error);
            await ctx.reply('‚ùå Broadcast preparation failed');
        }
    }

    async handleBroadcastInput(ctx, text) {
        await this.handleBroadcast(ctx);
    }

    async confirmBroadcast(ctx) {
        try {
            if (!ctx.session.broadcastMessage) {
                await ctx.answerCbQuery('‚ùå No message to broadcast');
                return;
            }

            await ctx.answerCbQuery('üì¢ Starting broadcast...');

            const processingMessage = `üì¢ **Broadcasting...**

üîÑ Sending your message to all users...

This may take several minutes. You'll receive a report when complete.`;

            await ctx.editMessageText(processingMessage, { parse_mode: 'Markdown' });

            // Start broadcast
            const result = await this.notificationService.broadcast(ctx.session.broadcastMessage);

            const resultMessage = `üì¢ **Broadcast Complete!**

**üìä Delivery Report:**
‚Ä¢ ‚úÖ Sent: ${result.sent}
‚Ä¢ ‚ùå Failed: ${result.failed}
‚Ä¢ üì± Total: ${result.total}
‚Ä¢ üìà Success Rate: ${Math.round((result.sent / result.total) * 100)}%

Broadcast completed successfully! üéâ`;

            const keyboard = Markup.inlineKeyboard([
                [Markup.button.callback('üîô Back to Admin', 'admin_main')]
            ]);

            await ctx.editMessageText(resultMessage, {
                parse_mode: 'Markdown',
                ...keyboard
            });

            // Clear session
            delete ctx.session.broadcastMessage;
            ctx.session.step = null;

        } catch (error) {
            console.error('‚ùå Confirm broadcast error:', error);
            await ctx.editMessageText('‚ùå Broadcast failed. Please try again.');
        }
    }

    // Helper methods
    isAdmin(userId) {
        return this.adminUserIds.includes(userId.toString());
    }

    calculateSuccessRate(transactions) {
        if (!transactions || transactions.total_transactions === 0) return 0;
        return Math.round((transactions.confirmed_transactions / transactions.total_transactions) * 100);
    }

    getStatusEmoji(status) {
        const emojis = {
            'pending': '‚è≥',
            'confirmed': '‚úÖ',
            'failed': '‚ùå'
        };
        return emojis[status] || '‚ùì';
    }

    async showUsersPage(ctx, page) {
        await this.showUsers(ctx, page);
    }

    async showTransactionsPage(ctx, page) {
        await this.showTransactions(ctx, page);
    }
}

module.exports = AdminHandler;
const { Markup } = require('telegraf');
const UserService = require('../../services/UserService');
const BlockchainService = require('../../services/BlockchainService');
const { formatNumber } = require('../../utils/formatting');

class WalletHandler {
    constructor() {
        this.userService = new UserService();
        this.blockchainService = new BlockchainService();
    }

    async handle(ctx) {
        try {
            const telegramId = ctx.from.id.toString();
            const user = await this.userService.getUserByTelegramId(telegramId);
            
            if (!user) {
                await ctx.reply('‚ùå User not found. Please use /start to register.');
                return;
            }

            if (user.wallet_address) {
                await this.showWalletInfo(ctx, user);
            } else {
                await this.showConnectWallet(ctx, user);
            }

        } catch (error) {
            console.error('‚ùå Wallet handler error:', error);
            await ctx.reply('‚ùå Wallet operation failed. Please try again.');
        }
    }

    async showConnectWallet(ctx, user) {
        const message = `üí≥ **Connect Your BSC Wallet**

üîó **To participate in our membership program, you need a BSC wallet.**

**üéØ Supported Wallets:**
‚Ä¢ **MetaMask** (Recommended)
‚Ä¢ **Trust Wallet**
‚Ä¢ **SafePal Wallet**
‚Ä¢ **Binance Chain Wallet**
‚Ä¢ Any BSC-compatible wallet

**üìã What you'll need:**
‚Ä¢ USDT tokens for membership fees
‚Ä¢ Small amount of BNB for gas fees
‚Ä¢ BSC (Binance Smart Chain) network added

**üîí Security Notice:**
‚Ä¢ We only store your wallet address
‚Ä¢ Never share your private keys
‚Ä¢ Always verify transactions before signing

**üì± Ready to connect your wallet?**

Send your BSC wallet address (starts with 0x) or use the button below for help! üëá`;

        const keyboard = Markup.inlineKeyboard([
            [
                Markup.button.callback('üí° Wallet Setup Guide', 'action_wallet_setup_guide'),
                Markup.button.callback('üåê Add BSC Network', 'action_bsc_network_help')
            ],
            [
                Markup.button.callback('üì± MetaMask Guide', 'action_metamask_guide'),
                Markup.button.callback('üíº Trust Wallet Guide', 'action_trust_wallet_guide')
            ],
            [
                Markup.button.callback('‚ùì FAQ', 'action_wallet_faq'),
                Markup.button.callback('üîô Back', 'action_back_main')
            ]
        ]);

        if (ctx.callbackQuery) {
            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();
        } else {
            await ctx.reply(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
        }

        // Set conversation state to wait for wallet address
        ctx.session.step = 'waiting_wallet_address';
    }

    async showWalletInfo(ctx, user) {
        try {
            const walletAddress = user.wallet_address;
            const shortAddress = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
            
            // Get blockchain info
            const memberInfo = await this.blockchainService.getMemberInfo(walletAddress);
            
            // Get USDT balance
            let usdtBalance = '0';
            let bnbBalance = '0';
            
            try {
                const usdtBal = await this.blockchainService.usdtContract.balanceOf(walletAddress);
                usdtBalance = this.blockchainService.formatTokenAmount(usdtBal.toString());
                
                const bnbBal = await this.blockchainService.provider.getBalance(walletAddress);
                bnbBalance = this.blockchainService.formatTokenAmount(bnbBal.toString(), 18);
            } catch (error) {
                console.error('‚ùå Error getting wallet balances:', error);
            }

            const message = `üí≥ **Your Wallet Information**

**üîó Connected Wallet:**
\`${walletAddress}\`

**üí∞ Wallet Balances:**
‚Ä¢ **USDT:** ${formatNumber(parseFloat(usdtBalance))} USDT
‚Ä¢ **BNB:** ${formatNumber(parseFloat(bnbBalance), 4)} BNB

**üìä Membership Status:**
${memberInfo && memberInfo.isRegistered ? 
    `‚úÖ Registered Member (Plan ${memberInfo.planId})
üìà **On-chain Earnings:** ${this.blockchainService.formatTokenAmount(memberInfo.totalEarnings)} USDT
üë• **Direct Referrals:** ${memberInfo.totalReferrals}` :
    `‚ùå Not registered yet
üí° Use /register to join a membership plan`
}

**üîí Security Status:**
‚úÖ Wallet connected securely
‚úÖ Ready for transactions
${parseFloat(bnbBalance) > 0.001 ? '‚úÖ Sufficient BNB for gas' : '‚ö†Ô∏è Low BNB balance (need for gas fees)'}

**‚ö° Quick Actions:**`;

            const keyboard = this.getWalletInfoKeyboard(user, parseFloat(usdtBalance), parseFloat(bnbBalance));

            if (ctx.callbackQuery) {
                await ctx.editMessageText(message, {
                    parse_mode: 'Markdown',
                    ...keyboard
                });
                await ctx.answerCbQuery();
            } else {
                await ctx.reply(message, {
                    parse_mode: 'Markdown',
                    ...keyboard
                });
            }

        } catch (error) {
            console.error('‚ùå Show wallet info error:', error);
            await ctx.reply('‚ùå Failed to load wallet information.');
        }
    }

    getWalletInfoKeyboard(user, usdtBalance, bnbBalance) {
        const keyboard = [];

        // Action buttons based on user status and balances
        if (!user.is_registered) {
            if (usdtBalance >= 1 && bnbBalance >= 0.001) {
                keyboard.push([
                    Markup.button.callback('üöÄ Register Now', 'action_get_started')
                ]);
            } else {
                keyboard.push([
                    Markup.button.callback('üí∞ Get USDT', 'action_get_usdt_help'),
                    Markup.button.callback('‚õΩ Get BNB', 'action_get_bnb_help')
                ]);
            }
        } else {
            keyboard.push([
                Markup.button.callback('‚¨ÜÔ∏è Upgrade Plan', 'action_upgrade'),
                Markup.button.callback('üìä Check Allowance', 'action_check_allowance')
            ]);
        }

        keyboard.push([
            Markup.button.callback('üîÑ Refresh Balances', 'action_wallet_info'),
            Markup.button.callback('üìã Transaction History', 'action_tx_history')
        ]);

        keyboard.push([
            Markup.button.callback('üîó View on BSCScan', 'action_view_bscscan'),
            Markup.button.callback('üîÑ Change Wallet', 'action_change_wallet')
        ]);

        keyboard.push([
            Markup.button.callback('‚ùì Wallet Help', 'action_wallet_help'),
            Markup.button.callback('üîô Back', 'action_back_main')
        ]);

        return Markup.inlineKeyboard(keyboard);
    }

    async handleWalletInput(ctx, walletAddress) {
        try {
            // Validate wallet address format
            if (!this.isValidWalletAddress(walletAddress)) {
                await ctx.reply(`‚ùå **Invalid wallet address format**

Please send a valid BSC wallet address that:
‚Ä¢ Starts with "0x"
‚Ä¢ Is exactly 42 characters long
‚Ä¢ Contains only hexadecimal characters

**Example:** \`0x1234567890123456789012345678901234567890\`

Try again or use /wallet for help! üí°`);
                return;
            }

            // Check if wallet is already used
            const existingUser = await this.userService.getUserByWalletAddress(walletAddress);
            if (existingUser && existingUser.telegram_id !== ctx.from.id.toString()) {
                await ctx.reply(`‚ùå **Wallet Already Connected**

This wallet address is already linked to another account.

**Options:**
‚Ä¢ Use a different wallet address
‚Ä¢ Contact support if this is your wallet
‚Ä¢ Check if you have another Telegram account

Please send a different wallet address! üí≥`);
                return;
            }

            // Show confirmation
            await this.showWalletConfirmation(ctx, walletAddress);

        } catch (error) {
            console.error('‚ùå Handle wallet input error:', error);
            await ctx.reply('‚ùå Failed to process wallet address. Please try again.');
        }
    }

    async showWalletConfirmation(ctx, walletAddress) {
        const shortAddress = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
        
        // Try to get wallet info
        let walletInfo = '';
        try {
            const usdtBalance = await this.blockchainService.usdtContract.balanceOf(walletAddress);
            const bnbBalance = await this.blockchainService.provider.getBalance(walletAddress);
            
            const usdtFormatted = this.blockchainService.formatTokenAmount(usdtBalance.toString());
            const bnbFormatted = this.blockchainService.formatTokenAmount(bnbBalance.toString(), 18);
            
            walletInfo = `\n**üí∞ Wallet Balances:**
‚Ä¢ USDT: ${formatNumber(parseFloat(usdtFormatted))} USDT
‚Ä¢ BNB: ${formatNumber(parseFloat(bnbFormatted), 4)} BNB`;

        } catch (error) {
            walletInfo = '\n‚ö†Ô∏è Unable to fetch wallet balances';
        }

        const message = `üîó **Confirm Wallet Connection**

**Wallet Address:**
\`${walletAddress}\`

**Short Address:** ${shortAddress}${walletInfo}

**‚úÖ This wallet will be used for:**
‚Ä¢ Membership registration payments
‚Ä¢ Plan upgrade payments  
‚Ä¢ Receiving referral commissions
‚Ä¢ All blockchain transactions

**‚ö†Ô∏è Important:**
‚Ä¢ Make sure you control this wallet
‚Ä¢ Keep your private keys secure
‚Ä¢ This can be changed later if needed

**Confirm connecting this wallet?**`;

        const keyboard = Markup.inlineKeyboard([
            [
                Markup.button.callback('‚úÖ Connect Wallet', `confirm_wallet_${walletAddress}`),
                Markup.button.callback('‚ùå Cancel', 'action_connect_wallet')
            ],
            [
                Markup.button.callback('üîç Verify on BSCScan', `verify_wallet_${walletAddress}`)
            ]
        ]);

        await ctx.reply(message, {
            parse_mode: 'Markdown',
            ...keyboard
        });

        // Clear session step
        ctx.session.step = null;
    }

    async connect(ctx) {
        await this.showConnectWallet(ctx, ctx.session.user);
    }

    async disconnect(ctx) {
        try {
            const telegramId = ctx.from.id.toString();
            const user = await this.userService.getUserByTelegramId(telegramId);
            
            if (!user || !user.wallet_address) {
                await ctx.answerCbQuery('‚ùå No wallet connected');
                return;
            }

            if (user.is_registered) {
                await ctx.answerCbQuery('‚ùå Cannot disconnect wallet of registered member');
                return;
            }

            const message = `üîì **Disconnect Wallet**

**Current Wallet:** \`${user.wallet_address.slice(0, 6)}...${user.wallet_address.slice(-4)}\`

**‚ö†Ô∏è Warning:**
‚Ä¢ You'll need to reconnect to register
‚Ä¢ This action cannot be undone
‚Ä¢ Make sure you have the wallet address saved

**Are you sure you want to disconnect?**`;

            const keyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback('‚úÖ Yes, Disconnect', 'confirm_disconnect_wallet'),
                    Markup.button.callback('‚ùå Cancel', 'action_wallet_info')
                ]
            ]);

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();

        } catch (error) {
            console.error('‚ùå Disconnect wallet error:', error);
            await ctx.answerCbQuery('‚ùå Failed to disconnect wallet');
        }
    }

    async confirmConnect(ctx, walletAddress) {
        try {
            const telegramId = ctx.from.id.toString();
            
            // Update user wallet address
            await this.userService.updateWalletAddress(telegramId, walletAddress);
            
            const shortAddress = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
            
            const message = `‚úÖ **Wallet Connected Successfully!**

**Connected Wallet:** \`${shortAddress}\`

üéâ Your BSC wallet is now connected to your account!

**üöÄ What's Next:**
‚Ä¢ Check your USDT balance for membership fees
‚Ä¢ Ensure you have BNB for gas fees
‚Ä¢ Ready to register for membership plans!

**‚ö° Quick Actions:**`;

            const keyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback('üöÄ Register Now', 'action_get_started'),
                    Markup.button.callback('üí∞ Check Balance', 'action_wallet_info')
                ],
                [
                    Markup.button.callback('üìã View Plans', 'action_view_plans'),
                    Markup.button.callback('üí° How to Get USDT', 'action_get_usdt_help')
                ],
                [
                    Markup.button.callback('üè† Main Menu', 'action_back_main')
                ]
            ]);

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery('‚úÖ Wallet connected successfully!');

        } catch (error) {
            console.error('‚ùå Confirm connect error:', error);
            await ctx.answerCbQuery('‚ùå Failed to connect wallet');
        }
    }

    async confirmDisconnect(ctx) {
        try {
            const telegramId = ctx.from.id.toString();
            
            // Clear wallet address
            await this.userService.updateWalletAddress(telegramId, null);
            
            const message = `üîì **Wallet Disconnected**

Your wallet has been successfully disconnected from your account.

**To participate again:**
‚Ä¢ Use /wallet to connect a new wallet
‚Ä¢ Ensure you have USDT and BNB
‚Ä¢ Complete membership registration

Need help? Use /help for assistance! üí°`;

            const keyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback('üí≥ Connect New Wallet', 'action_connect_wallet'),
                    Markup.button.callback('üè† Main Menu', 'action_back_main')
                ]
            ]);

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery('‚úÖ Wallet disconnected');

        } catch (error) {
            console.error('‚ùå Confirm disconnect error:', error);
            await ctx.answerCbQuery('‚ùå Failed to disconnect wallet');
        }
    }

    async showWalletHelp(ctx) {
        const message = `üí° **Wallet Help & Guides**

**üîó Setting Up Your BSC Wallet:**

**üì± MetaMask Setup:**
1. Download MetaMask app/extension
2. Create new wallet or import existing
3. Add BSC network (details below)
4. Transfer USDT and BNB to wallet

**üåê BSC Network Settings:**
‚Ä¢ **Network Name:** Smart Chain
‚Ä¢ **RPC URL:** https://bsc-dataseed.binance.org/
‚Ä¢ **Chain ID:** 56 (Mainnet) / 97 (Testnet)
‚Ä¢ **Symbol:** BNB
‚Ä¢ **Explorer:** https://bscscan.com

**üí∞ Getting Tokens:**
‚Ä¢ **USDT:** Buy on Binance, transfer to BSC
‚Ä¢ **BNB:** Needed for gas fees (~$1-2 worth)

**üîí Security Tips:**
‚Ä¢ Never share private keys
‚Ä¢ Use hardware wallet for large amounts
‚Ä¢ Verify all transaction details
‚Ä¢ Keep seed phrase secure

Need more help? Contact support! üÜò`;

        const keyboard = Markup.inlineKeyboard([
            [
                Markup.button.callback('üì± MetaMask Tutorial', 'action_metamask_tutorial'),
                Markup.button.callback('üíº Trust Wallet Guide', 'action_trust_tutorial')
            ],
            [
                Markup.button.callback('üåê Add BSC Network', 'action_add_bsc_network'),
                Markup.button.callback('üí∞ Get USDT Guide', 'action_get_usdt_guide')
            ],
            [
                Markup.button.callback('üîô Back to Wallet', 'action_wallet_info')
            ]
        ]);

        await ctx.editMessageText(message, {
            parse_mode: 'Markdown',
            ...keyboard
        });
        await ctx.answerCbQuery();
    }

    // Helper methods
    isValidWalletAddress(address) {
        return /^0x[a-fA-F0-9]{40}$/.test(address);
    }

    async showTransactionHistory(ctx) {
        try {
            const telegramId = ctx.from.id.toString();
            const user = await this.userService.getUserByTelegramId(telegramId);
            
            if (!user || !user.wallet_address) {
                await ctx.answerCbQuery('‚ùå No wallet connected');
                return;
            }

            // Get recent transactions from database
            const db = require('../../config/database').getDatabase();
            const transactions = await db.all(`
                SELECT * FROM transactions 
                WHERE user_id = (SELECT id FROM users WHERE telegram_id = ?)
                ORDER BY created_at DESC 
                LIMIT 10
            `, [telegramId]);

            let message = `üìã **Transaction History**\n\n`;

            if (transactions.length === 0) {
                message += 'üì≠ No transactions found.\n\nStart by registering for a membership plan!';
            } else {
                transactions.forEach((tx, index) => {
                    const status = this.getStatusEmoji(tx.status);
                    const type = tx.type.toUpperCase();
                    const amount = formatNumber(parseFloat(tx.amount));
                    const date = new Date(tx.created_at).toLocaleDateString();
                    
                    message += `${status} **${type}** - ${amount} USDT\n`;
                    message += `   ${date} ‚Ä¢ \`${tx.tx_hash?.slice(0, 10)}...\`\n\n`;
                });
                
                message += `**Total:** ${transactions.length} transactions shown`;
            }

            const keyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback('üîÑ Refresh', 'action_tx_history'),
                    Markup.button.callback('üîç View on BSCScan', 'action_view_bscscan')
                ],
                [
                    Markup.button.callback('üîô Back to Wallet', 'action_wallet_info')
                ]
            ]);

            await ctx.editMessageText(message, {
                parse_mode: 'Markdown',
                ...keyboard
            });
            await ctx.answerCbQuery();

        } catch (error) {
            console.error('‚ùå Show transaction history error:', error);
            await ctx.answerCbQuery('‚ùå Failed to load transaction history');
        }
    }

    getStatusEmoji(status) {
        const emojis = {
            'pending': '‚è≥',
            'confirmed': '‚úÖ',
            'failed': '‚ùå'
        };
        return emojis[status] || '‚ùì';
    }
}

module.exports = WalletHandler;